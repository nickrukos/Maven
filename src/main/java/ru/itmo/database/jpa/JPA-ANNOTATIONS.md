1. `@Entity` - класс - сущность, на основе entity класса в БД будет создана таблица. По умолчанию, имя класса в нижнем
   регистре = имя таблицы. Поля такого класса, соответствующие правилам, станут столбцами в созданной таблице. Является
   обязательной.

2. `@MappedSuperclass` - класс сам не является entity классом, но хранит информацию, общую для нескольких entity
   классов.
   Entity классы наследуются от супер-класса, унаследованные поля (отвечающие требованиям) станут столбцами таблицы,
   которая будет создана на основе entity.
3. `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)` - к родительскому entity классу. Позволяет задать стратегию
   наследования SINGLE_TABLE. Может быть дополнена
   аннотацией `@DiscriminatorColumn(name="название", discriminatorType = DiscriminatorType.ТИП)`, где name - название
   дополнительного столбца, discriminatorType - тип данных. Дополнительный столбец нужен, чтобы ORM мог определить,
   какому классу принадлежать те или иные столбцы. При изменении типа данных дочерние классы нужно аннотировать
   `@DiscriminatorValue("значение")`. `значение` будет сохранено в дополнительном столбце, оно должно быть уникальным
   для каждого дочернего типа (класса)
4. `@Inheritance(strategy = InheritanceType.JOINED)` - к родительскому entity классу. Позволяет задать стратегию
   наследования JOINED. Дочерним классам можно добавить аннотацию `@PrimaryKeyJoinColumn` и добавить описание
   идентификатору, например, указать название.
5. `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)` - к родительскому entity классу. Позволяет задать
   стратегию наследования TABLE_PER_CLASS.

6. `@Table` - для описания, создаваемой таблицы. Не является обязательной. Можно указать:

    1) `@Table(name = "название")` - название таблицы, создаваемой в БД
    2) `@Table(catalog = "название")` - catalog в БД, которой принадлежит таблица (если каталоги поддерживаются СУБД)
    3) `@Table(schema = "название")` - schema в БД, которой принадлежит таблица (если схемы поддерживаются СУБД)
    4) Индексы (простые, уникальные, составные, один или несколько). Позволяет создать составные индексы. Не
       используется
       для объявления первичных ключей (PRIMARY KEY).

               // уникальный индекс на поле phone
               @Table(indexes = @Index(columnList = "phone", unique = true)) 

               // индекс на поле title (не уникальный) 
               @Table(indexes = @Index(columnList = "title")) 

               // составной уникальный индекс на поля code и login
               @Table(indexes = @Index(columnList = "code, login", unique = true)) 

               // уникальный индекс на поле token
               // индекс на столбец price (не уникальный) 
               @Table(indexes = {
                            @Index(columnList = "token", unique = true),
                            @Index(columnList = "price")
                                 })

    5) `@Table(uniqueConstraints = @UniqueConstraint(columnNames = "category"))` - можно описать поле, которое является
       внешним ключом. Вместо этого лучше использовать аннотации `Column` и `JoinColumn`.

7. `@Column` - для описания столбца таблицы. Не является обязательной. Можно указать:
    1) `@Column(name = "название")` - название столбца в таблице (имя столбца = имя поля класса в нижнем регистре, если
       не указывать)
    2) `@Column(nullable = true)` - значения по столбцу не могут быть null (false, если не указывать)
    3) `@Column(unique = true)` - столбец - уникальный индекс (не является индексом, если не указывать). Можно указать
       на уровне аннотации `@Table`
    4) `@Column(insertable = false)` - недоступна операция вставки (SQL INSERT) по данному столбцу (вставка доступна по
       умолчанию)
    5) `@Column(updatable = false)` - недоступна операции обновления (SQL UPDATE) по данному столбцу (обновление
       доступно по умолчанию)
    6) `@Column(columnDefinition = "тип данных другие характеристики столбца")` - позволяет описать столбец на SQL
       синтаксисе, начиная с типа данных
    7) `@Column(length = число)` - максимальный размер строки, если столбец строкового типа (255, если не указывать)
    8) `@Column(precision = число, scale = число)` - для описания типа данных decimal (SQL). precision - всего цифр,
       scale - цифр после запятой

8. `@Id` - уникальный идентификатор сущности. Уникальный идентификатор записи в таблице (PRIMARY KEY). Может
   использоваться с одной из стратегий автогенерации (для числовых значений).
9. `@GeneratedValue` (добавляется к полю с аннотацией `@Id`). Числовые значения по полю будут генерироваться
   автоматически.
    1) `@GeneratedValue(strategy = GenerationType.AUTO)` - стратегия генерации значений определяется возможностями базы
       данных
    2) `@GeneratedValue(strategy = GenerationType.SEQUENCE)` - использует встроенный в базы данных, такие как PostgreSQL
       или Oracle, механизм генерации последовательных значений (sequence)
    3) `@GeneratedValue(strategy = GenerationType.TABLE)` - не зависит от поддержки конкретной базой данных и хранит
       счётчики значений в отдельной таблице
    4) `@GeneratedValue(strategy = GenerationType.IDENTITY)` значения по столбцу увеличиваются на 1 (например,
       AUTO_INCREMENT или SERIAL). СУБД должна поддерживать такую возможность

10. `@IdClass(ссылка на класс)` - используется, чтобы указать, какой класс описывает составной первичный ключ. Составной
    первичный ключ также можно объявить через аннотации `@Embeddable` и `@EmbeddedId`

           // класс описывает составной первичный ключ
           public class PK implements Serializable { // Serializable обязателен
               privete String title;
               private String city;
               // конструктор без аргументов обязателен
               // equals и hashCode обязательны
           }
        
           @IdClass(PK.class) // класс Company использует PK как описание составного первичного ключа
           public class Company {
               // в класс необходимо скопировать все свойства из PK,
               // добавить к каждому аннотацию @Id
               @Id
               privete String title;
               @Id    
               private String city;
           }

11. `@Embeddable` - для класса, который описывает составной первичный ключ. `@EmbeddedId` - для поля, которе ссылается
    на составной первичный ключ (вместо аннотации @Id).

        public class Company {
            
            @EmbeddedId // составной первичный ключ
            private PK primaryKey;

            @Embeddable // класс описывает составной первичный ключ
            public static class PK implements Serializable { // Serializable обязателен
                privete String title;
                private String city;
                // конструктор без аргументов обязателен
                // equals и hashCode обязательны
            }
        }

И в случае использования аннотаций `@IdClass` + `@Id`, и в случае использования аннотаций `@Embeddable` + `@EmbeddedId`,
составной первичный ключ (`PRIMARY KEY`) для Company - столбцы `title` и `city`. Сочетания значений по данным столбцам
уникально идентифицирую запись в таблице. При вставке значения title могут повторяться, как и значения city, но не их
сочетание. Извлечение, обновление и удаление по составному первичному ключу - проверка значений сразу по двум
столбцам: ... `WHERE title = ? AND city = ?`

12. `@ManyToMany` - для описания связи многое-ко-многим между сущностями. Аннотируются свойства типа Collection обоих
    entity классов. Для класса-владельца связи достаточно указанной аннотации. С другой стороны связи к аннотации
    необходимо добавить значение `mappedBy = "имя"`, где `имя` - имя поля в классе-владельце. Если аннотируется поле
    только с одной стороны, связь считается однонаправленной.

         @Entity
         public class Task { // владелец связи задачи - исполнители
            @ManyToMany
            private List<> ; 
         }

         @Entity
         public class Task { 
            @ManyToMany(mappedBy = "")
            private List<Task> tasks; 
         }   
         // таблица связей tasks_ будет создавана ORM'ом, 
         // внешние ключи этой таблицы будут ссылаться на таблицы Task и 

Аннотации можно (опционально) указать следующие параметры:

1) `@ManyToMany(fetch = FetchType.EAGER)` - выбрать стратегию извлечения данных EAGER. Значение FetchType.LAZY
   используется по умолчанию.
2) `@ManyToMany(cascade = CascadeType.PERSISTS)` или `@ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})` -
   транзиентные вставка, обновление, удаление и т.д. связанных сущностей.

13. `@JoinTable` - можно добавить к аннотации `@ManyToMany` Для описания таблицы связей. Правильно указывать на стороне
    владельца связей.
    1) `@JoinTable(name = "имя")` - задать имя генерируемой таблицы.
    2) `@JoinTable(joinColumns = @JoinColumn(name = "имя"))` - задать имя столбца, по которому таблица связей будет
       связана с текущей.
    3) `@JoinTable(inverseJoinColumns = @JoinColumn(name = "имя"))` - задать имя столбца, по которому таблица связей
       будет связана со второй таблицей.
14. `@ManyToOne` - для описания связи многое-к-одному между сущностями. Можно указать значения следующих параметров:
    1) `@ManyToOne(fetch = FetchType.LAZY)` - значение FetchType.EAGER используется по умолчанию.
    2) `@ManyToOne(cascade = CascadeType.PERSISTS)`
       или `@ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})` - транзиентные вставка, обновление,
       удаление и т.д. связанных сущностей.
    3) `@ManyToOne(optional = false)` - указание на то, что связь является обязательной. Значение true используется по
       умолчанию.
15. `@JoinColumn` - можно добавить к связи `@ManyToOne` для описания столбца, который является внешним ключом, по
    нему текущая таблица связана с другой таблицей. Параметры аннотации:
    1) `@JoinColumn(name = "имя")` - задать имя столбца.
    2) `@JoinColumn(unique = true)` - столбец - уникальный индекс (не является индексом, если не указывать). Можно
       указать на уровне аннотации `@Table`
    3) `@JoinColumn(insertable = false)` - недоступна операция вставки (SQL INSERT) по данному столбцу (вставка доступна
       по умолчанию)
    4) `@JoinColumn(updatable = false)` - недоступна операции обновления (SQL UPDATE) по данному столбцу (обновление
       доступно по умолчанию)
    5) `@JoinColumn(columnDefinition = "тип данных другие характеристики столбца")` - позволяет описать столбец на SQL
       синтаксисе, начиная с типа данных
16. `@OneToMany` - для описания связи один-ко-многим между сущностями. Необходимо указать значение
    параметра  `mappedBy = "имя"`, где `имя` - имя поля в классе-владельце. Можно добавить параметры:
    1) `@ManyToOne(fetch = FetchType.EAGER)` - значение FetchType.LAZY используется по умолчанию.
    2) `@ManyToOne(cascade = CascadeType.PERSISTS)`
       или `@ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})` - транзиентные вставка, обновление,
       удаление и т.д. связанных сущностей.
    3) `@ManyToOne(orphanRemoval = true)` - удалять данные о сущностях из таблицы, если они удалены из связи (
       коллекции). Значение false используется по умолчанию.
