1. `@Entity` - класс - сущность, на основе entity класса в БД будет создана таблица. По умолчанию, имя класса в нижнем
   регистре = имя таблицы. Поля такого класса, соответствующие правилам, станут столбцами в созданной таблице. Является
   обязательной.

2. `@MappedSuperclass` - класс сам не является entity классом, но хранит информацию, общую для нескольких entity
   классов.
   Entity классы наследуются от супер-класса, унаследованные поля (отвечающие требованиям) станут столбцами таблицы,
   которая будет создана на основе entity.
3. `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)` - к родительскому entity классу. Позволяет задать стратегию
   наследования SINGLE_TABLE. Может быть дополнена
   аннотацией `@DiscriminatorColumn(name="название", discriminatorType = DiscriminatorType.ТИП)`, где name - название
   дополнительного столбца, discriminatorType - тип данных. Дополнительный столбец нужен, чтобы ORM мог определить,
   какому классу принадлежать те или иные столбцы. При изменении типа данных дочерние классы нужно аннотировать
   `@DiscriminatorValue("значение")`. `значение` будет сохранено в дополнительном столбце, оно должно быть уникальным
   для каждого дочернего типа (класса)
4. `@Inheritance(strategy = InheritanceType.JOINED)` - к родительскому entity классу. Позволяет задать стратегию
   наследования JOINED. Дочерним классам можно добавить аннотацию `@PrimaryKeyJoinColumn` и добавить описание
   идентификатору, например, указать название.
5. `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)` - к родительскому entity классу. Позволяет задать
   стратегию наследования TABLE_PER_CLASS.

6. `@Table` - для описания, создаваемой таблицы. Не является обязательной. Можно указать:

    1) `@Table(name = "название")` - название таблицы, создаваемой в БД
    2) `@Table(catalog = "название")` - catalog в БД, которой принадлежит таблица (если каталоги поддерживаются СУБД)
    3) `@Table(schema = "название")` - schema в БД, которой принадлежит таблица (если схемы поддерживаются СУБД)
    4) Индексы (простые, уникальные, составные, один или несколько). Позволяет создать составные индексы. Не
       используется
       для объявления первичных ключей (PRIMARY KEY).

               // уникальный индекс на поле phone
               @Table(indexes = @Index(columnList = "phone", unique = true)) 

               // индекс на поле title (не уникальный) 
               @Table(indexes = @Index(columnList = "title")) 

               // составной уникальный индекс на поля code и login
               @Table(indexes = @Index(columnList = "code, login", unique = true)) 

               // уникальный индекс на поле token
               // индекс на столбец price (не уникальный) 
               @Table(indexes = {
                            @Index(columnList = "token", unique = true),
                            @Index(columnList = "price")
                                 })

    5) `@Table(uniqueConstraints = @UniqueConstraint(columnNames = "category"))` - можно описать поле, которое является
       внешним ключом. Вместо этого лучше использовать аннотации `Column` и `JoinColumn`.

7. `@Column` - для описания столбца таблицы. Не является обязательной. Можно указать:
    1) `@Column(name = "название")` - название столбца в таблице (имя столбца = имя поля класса в нижнем регистре, если
       не указывать)
    2) `@Column(nullable = true)` - значения по столбцу не могут быть null (false, если не указывать)
    3) `@Column(unique = true)` - столбец - уникальный индекс (не является индексом, если не указывать). Можно указать
       на уровне аннотации `@Table`
    4) `@Column(insertable = false)` - недоступна операция вставки (SQL INSERT) по данному столбцу (вставка доступна по
       умолчанию)
    5) `@Column(updatable = false)` - недоступна операции обновления (SQL UPDATE) по данному столбцу (обновление
       доступно по умолчанию)
    6) `@Column(columnDefinition = "тип данных другие характеристики столбца")` - позволяет описать столбец на SQL
       синтаксисе, начиная с типа данных
    7) `@Column(length = число)` - максимальный размер строки, если столбец строкового типа (255, если не указывать)
    8) `@Column(precision = число, scale = число)` - для описания типа данных decimal (SQL). precision - всего цифр,
       scale - цифр после запятой

8. `@Id` - уникальный идентификатор сущности. Уникальный идентификатор записи в таблице (PRIMARY KEY). Может
   использоваться с одной из стратегий автогенерации (для числовых значений).
9. `@GeneratedValue` (добавляется к полю с аннотацией `@Id`). Числовые значения по полю будут генерироваться
   автоматически.
    1) `@GeneratedValue(strategy = GenerationType.AUTO)` - стратегия генерации значений определяется возможностями базы
       данных
    2) `@GeneratedValue(strategy = GenerationType.SEQUENCE)` - использует встроенный в базы данных, такие как PostgreSQL
       или Oracle, механизм генерации последовательных значений (sequence)
    3) `@GeneratedValue(strategy = GenerationType.TABLE)` - не зависит от поддержки конкретной базой данных и хранит
       счётчики значений в отдельной таблице
    4) `@GeneratedValue(strategy = GenerationType.IDENTITY)` значения по столбцу увеличиваются на 1 (например,
       AUTO_INCREMENT или SERIAL). СУБД должна поддерживать такую возможность

10. `@IdClass(ссылка на класс)` - используется, чтобы указать, какой класс описывает составной первичный ключ. Составной
    первичный ключ также можно объявить через аннотации `@Embeddable` и `@EmbeddedId`


           // класс описывает составной первичный ключ
           public class PK implements Serializable { // Serializable обязателен
               privete String title;
               private String city;
               // конструктор без аргументов обязателен
               // equals и hashCode обязательны
           }
        
           @IdClass(PK.class) // класс Company использует PK как описание составного первичного ключа
           public class Company {
               // в класс необходимо скопировать все свойства из PK,
               // добавить к каждому аннотацию @Id
               @Id
               privete String title;
               @Id    
               private String city;
           }

11. `@Embeddable` - для класса, который описывает составной первичный ключ. `@EmbeddedId` - для поля, которе ссылается
    на составной первичный ключ (вместо аннотации @Id).

        public class Company {
            
            @EmbeddedId // составной первичный ключ
            private PK primaryKey;

            @Embeddable // класс описывает составной первичный ключ
            public static class PK implements Serializable { // Serializable обязателен
                privete String title;
                private String city;
                // конструктор без аргументов обязателен
                // equals и hashCode обязательны
            }
    }

И в случае использования аннотаций `@IdClass` + `@Id`, и в случае использования аннотаций `@Embeddable` + `@EmbeddedId`,
составной первичный ключ (`PRIMARY KEY`) для Company - столбцы `title` и `city`. Сочетания значений по данным столбцам
уникально идентифицирую запись в таблице. При вставке значения title могут повторяться, как и значения city, но не их
сочетание. Извлечение, обновление и удаление по составному первичному ключу - проверка значений сразу по двум
столбцам: ... `WHERE title = ? AND city = ?`

